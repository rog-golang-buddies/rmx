{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Note This is your project's home page. To-do Update the site_name config in the mkdocs.yml file within the root directory.","title":"Home"},{"location":"quickstart/","text":"Quickstart Provides the CI setup and local development instructions to optimally use this repository. \ud83d\ude80 Instructions are distilled to get you started with the least amount of effort. Highly recommend reading background information for context in the provided links. Install developer tools pip install --user pre-commit commitizen mkdocs-material For background on pre-commit please see pre-commit for further details. For background on commitizen please see commitizen for further details. For background on mkdocs-material please see mkdocs-material for further details. Setup base release for semantic-release \u26a0\ufe0f This is a one time activity. If a tag already exists in the repository this step is not required. If no tags exist proceed to read the next section. \u26a0\ufe0f Why is this required? Please see Base release version documentation for rationale. # Within the `main` branch in your git repo git tag -a v0.1.0 -m \"Pre-release\" git push origin v0.1.0 Documentation generation via mkdocs-material Enable gh-pages as per the CI setup instructions. Update site_name field in ./mkdocs.yml file. Get template repository updates (optional) Setup an additional remote to periodically get latest template repository updates. git remote add template https://github.com/rog-golang-buddies/golang-template-repository.git # Update git fetch template git merge template/ [ branch to merge ]","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Provides the CI setup and local development instructions to optimally use this repository. \ud83d\ude80 Instructions are distilled to get you started with the least amount of effort. Highly recommend reading background information for context in the provided links.","title":"Quickstart"},{"location":"quickstart/#install-developer-tools","text":"pip install --user pre-commit commitizen mkdocs-material For background on pre-commit please see pre-commit for further details. For background on commitizen please see commitizen for further details. For background on mkdocs-material please see mkdocs-material for further details.","title":"Install developer tools"},{"location":"quickstart/#setup-base-release-for-semantic-release","text":"\u26a0\ufe0f This is a one time activity. If a tag already exists in the repository this step is not required. If no tags exist proceed to read the next section. \u26a0\ufe0f Why is this required? Please see Base release version documentation for rationale. # Within the `main` branch in your git repo git tag -a v0.1.0 -m \"Pre-release\" git push origin v0.1.0","title":"Setup base release for semantic-release"},{"location":"quickstart/#documentation-generation-via-mkdocs-material","text":"Enable gh-pages as per the CI setup instructions. Update site_name field in ./mkdocs.yml file.","title":"Documentation generation via mkdocs-material"},{"location":"quickstart/#get-template-repository-updates-optional","text":"Setup an additional remote to periodically get latest template repository updates. git remote add template https://github.com/rog-golang-buddies/golang-template-repository.git # Update git fetch template git merge template/ [ branch to merge ]","title":"Get template repository updates (optional)"},{"location":"continuous-integration/gitleaks/","text":"gitleaks What gitleaks is a SAST tool for detecting and preventing hardcoded secrets like passwords, api keys, and tokens in git repos. Gitleaks is an easy-to-use, all-in-one solution for detecting secrets, past or present, in your code. Why Raise security incidents early by detecting secret leaks and raising Github security code scanning alerts. How The mechanism to detect secrets and protect (undo commit with a secret) is described here . CI setup Summary No configuration required. A gitleaks detect command is run via a gitleaks Github workflow in .github/workflows/gitleaks.yml . Info The gitleaks Github action has a paid license restriction, therefore a custom workflow has been setup instead. It will fail the secret scan if secrets are detected and push alerts to Github security. Local setup Done This is already configured for you via pre-commit .","title":"gitleaks"},{"location":"continuous-integration/gitleaks/#gitleaks","text":"","title":"gitleaks"},{"location":"continuous-integration/gitleaks/#what","text":"gitleaks is a SAST tool for detecting and preventing hardcoded secrets like passwords, api keys, and tokens in git repos. Gitleaks is an easy-to-use, all-in-one solution for detecting secrets, past or present, in your code.","title":"What"},{"location":"continuous-integration/gitleaks/#why","text":"Raise security incidents early by detecting secret leaks and raising Github security code scanning alerts.","title":"Why"},{"location":"continuous-integration/gitleaks/#how","text":"The mechanism to detect secrets and protect (undo commit with a secret) is described here .","title":"How"},{"location":"continuous-integration/gitleaks/#ci-setup","text":"Summary No configuration required. A gitleaks detect command is run via a gitleaks Github workflow in .github/workflows/gitleaks.yml . Info The gitleaks Github action has a paid license restriction, therefore a custom workflow has been setup instead. It will fail the secret scan if secrets are detected and push alerts to Github security.","title":"CI setup"},{"location":"continuous-integration/gitleaks/#local-setup","text":"Done This is already configured for you via pre-commit .","title":"Local setup"},{"location":"continuous-integration/golangci-lint/","text":"golangci-lint What golangci-lint is a Go linters aggregator. It runs linters in parallel, uses caching, supports yaml config, has integrations with all major IDE and has dozens of linters included. Why Provides Secure Application Security Testing, error, style etc. checks for your codebase. Tip See supported linters here . How Linters can be configured via command-line options or a configuration file . CI setup Summary No configuration required. golangci-lint will be executed via the pre-commit Github workflow in .github/workflows/pre-commit.yml . Local setup Done This is already configured for you via pre-commit . For custom configurations to modify how golangci-lint runs see the configuration guide . You may want to disable linters that might be too strict (e.g: exhaustivestruct ) or add some rules around how it should behave. This can be done via linter configuration .","title":"golangci-lint"},{"location":"continuous-integration/golangci-lint/#golangci-lint","text":"","title":"golangci-lint"},{"location":"continuous-integration/golangci-lint/#what","text":"golangci-lint is a Go linters aggregator. It runs linters in parallel, uses caching, supports yaml config, has integrations with all major IDE and has dozens of linters included.","title":"What"},{"location":"continuous-integration/golangci-lint/#why","text":"Provides Secure Application Security Testing, error, style etc. checks for your codebase. Tip See supported linters here .","title":"Why"},{"location":"continuous-integration/golangci-lint/#how","text":"Linters can be configured via command-line options or a configuration file .","title":"How"},{"location":"continuous-integration/golangci-lint/#ci-setup","text":"Summary No configuration required. golangci-lint will be executed via the pre-commit Github workflow in .github/workflows/pre-commit.yml .","title":"CI setup"},{"location":"continuous-integration/golangci-lint/#local-setup","text":"Done This is already configured for you via pre-commit . For custom configurations to modify how golangci-lint runs see the configuration guide . You may want to disable linters that might be too strict (e.g: exhaustivestruct ) or add some rules around how it should behave. This can be done via linter configuration .","title":"Local setup"},{"location":"continuous-integration/goreleaser/","text":"GoReleaser What GoReleaser builds Go binaries for several platforms. The goal is to simplify the build, release and publish steps while providing variant customization options for all steps. Why Simplifies the build and packing process of your app's Go binaries. How The entire release process can be customized through a .goreleaser.yml file. Once you set it up, every time you want to create a new release, all you need to do is create a git tag that conforms to semantic versioning and run goreleaser release . CI setup Summary No configuration required. GoReleaser is configured to run on the main branch and is executed via the release Github workflow in .github/workflows/release.yml . Info Binaries are only created if a tag exists. This is controlled via semantic-release . Local setup The quickstart provides detailed steps to run GoReleaser locally.","title":"GoReleaser"},{"location":"continuous-integration/goreleaser/#goreleaser","text":"","title":"GoReleaser"},{"location":"continuous-integration/goreleaser/#what","text":"GoReleaser builds Go binaries for several platforms. The goal is to simplify the build, release and publish steps while providing variant customization options for all steps.","title":"What"},{"location":"continuous-integration/goreleaser/#why","text":"Simplifies the build and packing process of your app's Go binaries.","title":"Why"},{"location":"continuous-integration/goreleaser/#how","text":"The entire release process can be customized through a .goreleaser.yml file. Once you set it up, every time you want to create a new release, all you need to do is create a git tag that conforms to semantic versioning and run goreleaser release .","title":"How"},{"location":"continuous-integration/goreleaser/#ci-setup","text":"Summary No configuration required. GoReleaser is configured to run on the main branch and is executed via the release Github workflow in .github/workflows/release.yml . Info Binaries are only created if a tag exists. This is controlled via semantic-release .","title":"CI setup"},{"location":"continuous-integration/goreleaser/#local-setup","text":"The quickstart provides detailed steps to run GoReleaser locally.","title":"Local setup"},{"location":"continuous-integration/mkdocs-material/","text":"mkdocs-material What mkdocs-material provides documentation in Markdown to create a professional static site in minutes \u2013 searchable, customizable, for all devices. Why From a developer experience perspective, it is easier to clone and have everything you need to reference locally rather than having to externally reference something i.e Github wiki, Confluence etc. This minimises context switching and aids the practice of keeping documentation updated as it is closer to the codebase. How The repository is preconfigured with a ./docs directory and renders all markdown files to generate a github-pages site. mkdocs-material is customizable via the mkdocs.yml configuration file available in the repository root directory. The configuration present is not exhaustive and can be further customized . CI setup Github pages mkdocs is configured to automatically run on the main branch and is executed via the mkdocs Github workflow in .github/workflows/mkdocs.yml . However, it requires github-pages to be enabled in the repository settings. See the screenshot below: The documentation contained within the ./docs directory will be automatically published and accessible via <org>.github.io/<repository>. Site name Update site_name field in ./mkdocs.yml file to set the main title for the project documentation. Local setup pip install mkdocs-material For more installtion options see here . Run a local server to preview docs: mkdocs serve","title":"mkdocs-material"},{"location":"continuous-integration/mkdocs-material/#mkdocs-material","text":"","title":"mkdocs-material"},{"location":"continuous-integration/mkdocs-material/#what","text":"mkdocs-material provides documentation in Markdown to create a professional static site in minutes \u2013 searchable, customizable, for all devices.","title":"What"},{"location":"continuous-integration/mkdocs-material/#why","text":"From a developer experience perspective, it is easier to clone and have everything you need to reference locally rather than having to externally reference something i.e Github wiki, Confluence etc. This minimises context switching and aids the practice of keeping documentation updated as it is closer to the codebase.","title":"Why"},{"location":"continuous-integration/mkdocs-material/#how","text":"The repository is preconfigured with a ./docs directory and renders all markdown files to generate a github-pages site. mkdocs-material is customizable via the mkdocs.yml configuration file available in the repository root directory. The configuration present is not exhaustive and can be further customized .","title":"How"},{"location":"continuous-integration/mkdocs-material/#ci-setup","text":"","title":"CI setup"},{"location":"continuous-integration/mkdocs-material/#github-pages","text":"mkdocs is configured to automatically run on the main branch and is executed via the mkdocs Github workflow in .github/workflows/mkdocs.yml . However, it requires github-pages to be enabled in the repository settings. See the screenshot below: The documentation contained within the ./docs directory will be automatically published and accessible via <org>.github.io/<repository>.","title":"Github pages"},{"location":"continuous-integration/mkdocs-material/#site-name","text":"Update site_name field in ./mkdocs.yml file to set the main title for the project documentation.","title":"Site name"},{"location":"continuous-integration/mkdocs-material/#local-setup","text":"pip install mkdocs-material For more installtion options see here . Run a local server to preview docs: mkdocs serve","title":"Local setup"},{"location":"continuous-integration/pre-commit/","text":"pre-commit What pre-commit is a wrapper for git hook scripts that are useful for identifying simple issues before submission to code review. Git hooks are run on every commit to automatically point out issues in code such as missing semicolons, trailing whitespace, and debug statements and integrate with a variety of third-party tooling. Why Eliminates the effort of initializing and managing git hooks locally. pre-commit also integrates with a large range of (hooks)[https://pre-commit.com/hooks.html] enabling a consistent developer experience. How A .pre-commit-config.yaml config file is configured with common and useful hoooks. This is available at the root of your repository. Each time you make a commit the pre-commit hooks run. If a hook supports applying auto-fixes (e.g: hook trailing-whitespace support fixing trailing whitespaces), it will proceed to fix it. Any detected failures will abort the commit. Tip See supported hooks here . CI setup Summary No configuration required. All hooks in .pre-commit-config.yaml will be executed via the automatic integration provided from pre-commit ci . pre-commit ci runs automatically on pull request commits. Auto fixing pull requests If tools (configured in .pre-commit-config.yaml ) make changes to files during a pull request, pre-commit.ci will automatically fix the pull request. pre-commit.ci will run on all pull request commits, but will not push for commits made by bots. The impact of this means developers will need to fetch the latest changes if further work must be done on the PR branch. Local setup pip install -u pre-commit For more installtion options see here . Install the hooks configured in .pre-commit-config.yaml : pre-commit install Running against all files instead of only stages files: pre-commit run --all-files FAQ Do I have to run pre-commit install everytime I clone a repository? Yes. However, you can automatically enable pre-commit to run when you clone a repository via this link.","title":"pre-commit"},{"location":"continuous-integration/pre-commit/#pre-commit","text":"","title":"pre-commit"},{"location":"continuous-integration/pre-commit/#what","text":"pre-commit is a wrapper for git hook scripts that are useful for identifying simple issues before submission to code review. Git hooks are run on every commit to automatically point out issues in code such as missing semicolons, trailing whitespace, and debug statements and integrate with a variety of third-party tooling.","title":"What"},{"location":"continuous-integration/pre-commit/#why","text":"Eliminates the effort of initializing and managing git hooks locally. pre-commit also integrates with a large range of (hooks)[https://pre-commit.com/hooks.html] enabling a consistent developer experience.","title":"Why"},{"location":"continuous-integration/pre-commit/#how","text":"A .pre-commit-config.yaml config file is configured with common and useful hoooks. This is available at the root of your repository. Each time you make a commit the pre-commit hooks run. If a hook supports applying auto-fixes (e.g: hook trailing-whitespace support fixing trailing whitespaces), it will proceed to fix it. Any detected failures will abort the commit. Tip See supported hooks here .","title":"How"},{"location":"continuous-integration/pre-commit/#ci-setup","text":"Summary No configuration required. All hooks in .pre-commit-config.yaml will be executed via the automatic integration provided from pre-commit ci . pre-commit ci runs automatically on pull request commits.","title":"CI setup"},{"location":"continuous-integration/pre-commit/#auto-fixing-pull-requests","text":"If tools (configured in .pre-commit-config.yaml ) make changes to files during a pull request, pre-commit.ci will automatically fix the pull request. pre-commit.ci will run on all pull request commits, but will not push for commits made by bots. The impact of this means developers will need to fetch the latest changes if further work must be done on the PR branch.","title":"Auto fixing pull requests"},{"location":"continuous-integration/pre-commit/#local-setup","text":"pip install -u pre-commit For more installtion options see here . Install the hooks configured in .pre-commit-config.yaml : pre-commit install Running against all files instead of only stages files: pre-commit run --all-files","title":"Local setup"},{"location":"continuous-integration/pre-commit/#faq","text":"Do I have to run pre-commit install everytime I clone a repository? Yes. However, you can automatically enable pre-commit to run when you clone a repository via this link.","title":"FAQ"},{"location":"continuous-integration/semantic-release/","text":"semantic-release What semantic-release automates the whole package release workflow including determining the next version number, generating the release notes, and publishing the package. semantic-release uses the commit messages to determine the consumer impact of changes in the codebase. Following formalized conventions for commit messages, semantic-release automatically determines the next semantic version number, generates a changelog and publishes the release. Why Follow a well-established commit message convention that encourages your team to have structured commits and provides the controls via commits to automatically version your codebase & publish a release. How Commit message convention The formalized convention is as follows for commit messages: <type>(<scope>): <short summary> \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2af8 Summary in present tense. Not capitalized. No period at the end. \u2502 \u2502 \u2502 \u2514\u2500\u2af8 Commit Scope: A scope MUST consist of a noun describing a section of the codebase surrounded by parenthesis \u2502 \u2514\u2500\u2af8 Commit Type: build|ci|docs|feat|fix|perf|refactor|test Example Commit message Release type fix(pencil): stop graphite breaking when too much pressure applied Fix Release feat(pencil): add 'graphiteWidth' option Feature Release perf(pencil): remove graphiteWidth option BREAKING CHANGE: The graphiteWidth option has been removed. The default graphite width of 10mm is always used for performance reasons. Breaking Release (Note that the BREAKING CHANGE: token must be in the footer of the commit) For a base version of 0.1.0 , the following will apply: Type Release type example Notes fix increments to 0.1.1 feat increments to 0.1.0 Resets any existing patch fixes e.g: 0.1.3 will be 0.2.0 BREAKING CHANGE Increments to 1.0.0 Can be added to any type All others No version increment CI setup Warning This section covers important implications of setting up a base tag/release version (or lack of) in your repo before using semantic-release . Base release version semantic-release is configured to run on the main branch and is executed via the release Github workflow in .github/workflows/release.yml . Technically, no further setup is required. However, the initial version is set at v1.0.0 (with optional pre-release settings) instead of the generally accepted version v0.1.0 . This may not be desirable for your project so a workaround is described below. Info As per the semantic versioning spec , the initial development release should be v0.1.0 . Optionally you can set it to v0.0.0 if there is only an initial commit in the repo. In the Github repo page: Click on the Create a new release link on the right-hand panel Click on Choose a tag , type in your base version (e.g: v0.1.0 ) and hit enter Enter desired release title e.g: Pre-release Tick This is a pre-release checkbox Click the Publish button If you don't want to create a release and the steps above are one too many, you can create a tag via the command line: # Within the `main` branch in your git repo git tag -a v0.1.0 -m \"Pre-release\" git push origin v0.1.0 Local setup Commitizen Use commitzen to ease following the commit message convention described above . pip install -U commitizen For more installtion options see here . Info Stage some files in your repo and type cz commit and you're ready to go! Tip Decide on the commit convention scope in advance. This will keep it consistent and provide a coherent semantic mapping. FAQ I have many feat type commits to be added to main but I don't want to trigger a release For a Continous Deployment methodology, it is not uncommon to release small features frequently in isolation. This will undoubtedly increment your minor version but it is acceptable as it reflects the rapid changes in your project. Alternatively, if you wish to batch features to trigger a release here are some options: Release branch (recommended) Create a release branch and merge multiple feat type commits to it. When the release branch is ready and merged to main , it will condense the numerous feat type commits to generate a singular increment in the release version/tag. Non-standard commit type Use a custom commit type such as: # Feature no release (featnr) denotes a feature but is not release ready featnr ( pencil ) : add 'graphiteWidth' option","title":"semantic-release"},{"location":"continuous-integration/semantic-release/#semantic-release","text":"","title":"semantic-release"},{"location":"continuous-integration/semantic-release/#what","text":"semantic-release automates the whole package release workflow including determining the next version number, generating the release notes, and publishing the package. semantic-release uses the commit messages to determine the consumer impact of changes in the codebase. Following formalized conventions for commit messages, semantic-release automatically determines the next semantic version number, generates a changelog and publishes the release.","title":"What"},{"location":"continuous-integration/semantic-release/#why","text":"Follow a well-established commit message convention that encourages your team to have structured commits and provides the controls via commits to automatically version your codebase & publish a release.","title":"Why"},{"location":"continuous-integration/semantic-release/#how","text":"","title":"How"},{"location":"continuous-integration/semantic-release/#commit-message-convention","text":"The formalized convention is as follows for commit messages: <type>(<scope>): <short summary> \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2af8 Summary in present tense. Not capitalized. No period at the end. \u2502 \u2502 \u2502 \u2514\u2500\u2af8 Commit Scope: A scope MUST consist of a noun describing a section of the codebase surrounded by parenthesis \u2502 \u2514\u2500\u2af8 Commit Type: build|ci|docs|feat|fix|perf|refactor|test","title":"Commit message convention"},{"location":"continuous-integration/semantic-release/#example","text":"Commit message Release type fix(pencil): stop graphite breaking when too much pressure applied Fix Release feat(pencil): add 'graphiteWidth' option Feature Release perf(pencil): remove graphiteWidth option BREAKING CHANGE: The graphiteWidth option has been removed. The default graphite width of 10mm is always used for performance reasons. Breaking Release (Note that the BREAKING CHANGE: token must be in the footer of the commit) For a base version of 0.1.0 , the following will apply: Type Release type example Notes fix increments to 0.1.1 feat increments to 0.1.0 Resets any existing patch fixes e.g: 0.1.3 will be 0.2.0 BREAKING CHANGE Increments to 1.0.0 Can be added to any type All others No version increment","title":"Example"},{"location":"continuous-integration/semantic-release/#ci-setup","text":"Warning This section covers important implications of setting up a base tag/release version (or lack of) in your repo before using semantic-release .","title":"CI setup"},{"location":"continuous-integration/semantic-release/#base-release-version","text":"semantic-release is configured to run on the main branch and is executed via the release Github workflow in .github/workflows/release.yml . Technically, no further setup is required. However, the initial version is set at v1.0.0 (with optional pre-release settings) instead of the generally accepted version v0.1.0 . This may not be desirable for your project so a workaround is described below. Info As per the semantic versioning spec , the initial development release should be v0.1.0 . Optionally you can set it to v0.0.0 if there is only an initial commit in the repo. In the Github repo page: Click on the Create a new release link on the right-hand panel Click on Choose a tag , type in your base version (e.g: v0.1.0 ) and hit enter Enter desired release title e.g: Pre-release Tick This is a pre-release checkbox Click the Publish button If you don't want to create a release and the steps above are one too many, you can create a tag via the command line: # Within the `main` branch in your git repo git tag -a v0.1.0 -m \"Pre-release\" git push origin v0.1.0","title":"Base release version"},{"location":"continuous-integration/semantic-release/#local-setup","text":"","title":"Local setup"},{"location":"continuous-integration/semantic-release/#commitizen","text":"Use commitzen to ease following the commit message convention described above . pip install -U commitizen For more installtion options see here . Info Stage some files in your repo and type cz commit and you're ready to go! Tip Decide on the commit convention scope in advance. This will keep it consistent and provide a coherent semantic mapping.","title":"Commitizen"},{"location":"continuous-integration/semantic-release/#faq","text":"I have many feat type commits to be added to main but I don't want to trigger a release For a Continous Deployment methodology, it is not uncommon to release small features frequently in isolation. This will undoubtedly increment your minor version but it is acceptable as it reflects the rapid changes in your project. Alternatively, if you wish to batch features to trigger a release here are some options: Release branch (recommended) Create a release branch and merge multiple feat type commits to it. When the release branch is ready and merged to main , it will condense the numerous feat type commits to generate a singular increment in the release version/tag. Non-standard commit type Use a custom commit type such as: # Feature no release (featnr) denotes a feature but is not release ready featnr ( pencil ) : add 'graphiteWidth' option","title":"FAQ"}]}